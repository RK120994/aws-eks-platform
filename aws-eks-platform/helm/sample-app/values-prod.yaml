# Production Environment Values for sample-app Helm chart

# Environment-specific configuration
environment: prod

# Image configuration for production
image:
  repository: your-account.dkr.ecr.us-west-2.amazonaws.com/demo-app
  tag: ""  # Will be set by CI/CD pipeline
  pullPolicy: Always

# Resource limits for production (high performance)
resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 250m
    memory: 256Mi

# Autoscaling for production (high availability)
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 60
  targetMemoryUtilizationPercentage: 70

# Replica count when autoscaling is disabled
replicaCount: 3

# Environment variables for production
env:
  ENVIRONMENT: "production"
  LOG_LEVEL: "warn"
  PORT: "8000"
  HOST: "0.0.0.0"

# Secrets for production (use AWS Secrets Manager/External Secrets Operator)
secrets: {}  # Managed externally via AWS Secrets Manager

# ConfigMap for production
configMap:
  app.properties: |
    # Production Application properties
    app.name=sample-app
    app.debug=false
    app.environment=production
    app.cache.enabled=true
    app.cache.ttl=600
    app.performance.optimization=true
    
  logging.conf: |
    # Production Logging configuration
    version: 1
    disable_existing_loggers: false
    formatters:
      json:
        format: '{"timestamp":"%(asctime)s","name":"%(name)s","level":"%(levelname)s","message":"%(message)s","trace_id":"%(trace_id)s"}'
    handlers:
      console:
        class: logging.StreamHandler
        level: WARN
        formatter: json
    root:
      level: WARN
      handlers: [console]

# Ingress configuration for production
ingress:
  enabled: true
  className: "aws-load-balancer-controller"
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}]'
    alb.ingress.kubernetes.io/certificate-arn: ""  # Add your production SSL certificate ARN
    alb.ingress.kubernetes.io/tags: Environment=prod,Project=demo,CriticalWorkload=true
    alb.ingress.kubernetes.io/load-balancer-attributes: idle_timeout.timeout_seconds=300,routing.http2.enabled=true
    alb.ingress.kubernetes.io/healthcheck-path: /health/ready
    alb.ingress.kubernetes.io/healthcheck-interval-seconds: "15"
    alb.ingress.kubernetes.io/healthcheck-timeout-seconds: "5"
    alb.ingress.kubernetes.io/healthy-threshold-count: "2"
    alb.ingress.kubernetes.io/unhealthy-threshold-count: "3"
  hosts:
    - host: api.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: sample-app-prod-tls
      hosts:
        - api.example.com

# Health check configuration (production tuned)
healthCheck:
  enabled: true
  livenessProbe:
    httpGet:
      path: /health/live
      port: 8000
    initialDelaySeconds: 45
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  readinessProbe:
    httpGet:
      path: /health/ready
      port: 8000
    initialDelaySeconds: 30
    periodSeconds: 5
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 2

# Monitoring configuration
monitoring:
  enabled: true
  prometheus:
    enabled: true
    port: 8000
    path: /metrics
    scrapeInterval: 15s

# Pod annotations for production
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8000"
  prometheus.io/path: "/metrics"
  environment: "prod"

# Network policies (strict security)
networkPolicy:
  enabled: true
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: aws-load-balancer-controller
      ports:
        - protocol: TCP
          port: 8000
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: 8000
  egress:
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53
    - to: []
      ports:
        - protocol: TCP
          port: 443
        - protocol: TCP
          port: 5432

# Pod disruption budget (high availability)
podDisruptionBudget:
  enabled: true
  minAvailable: 2

# Production-specific labels
commonLabels:
  environment: prod
  tier: production
  criticality: high

# Production-specific annotations
commonAnnotations:
  deployed-by: "helm"
  environment: "production"
  backup: "daily"
  monitoring: "enhanced"
  compliance: "required"

# Service account with production IAM role
serviceAccount:
  create: true
  annotations:
    eks.amazonaws.com/role-arn: ""  # Add your production IAM role ARN

# Security context (maximum security)
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000

# Pod security context
podSecurityContext:
  fsGroup: 1000
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  seccompProfile:
    type: RuntimeDefault
  supplementalGroups: [1000]

# Production volumes
volumes:
  - name: tmp-volume
    emptyDir:
      sizeLimit: 1Gi

# Volume mounts
volumeMounts:
  - name: tmp-volume
    mountPath: /tmp

# Strict affinity rules for production
affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: app.kubernetes.io/name
          operator: In
          values:
          - sample-app
      topologyKey: kubernetes.io/hostname
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchExpressions:
        - key: node-type
          operator: In
          values:
          - production

# Node selector for production nodes
nodeSelector:
  environment: prod
  node-type: production

# Tolerations for production workloads
tolerations:
  - key: "production-workload"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"
  - key: "high-performance"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"

# Strategy for zero-downtime deployments
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0

# Priority class for production workloads
priorityClassName: "high-priority"
